#pragma config(Motor,  port1,           leftmotor,     tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port6,           clawmotor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           armmotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightmotor,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/*Righ motor is 76 not 60 because the right motor is not aligned properly
 * the value of 76 keeps it moving evenly(or at least kind of close) */
// moves forward
// "void" is a function
void moveForward(int timeMoving) {
	wait1Msec(250);
	motor[leftmotor] = 60;
	motor[rightmotor] = 76;
	wait1Msec(timeMoving);
	motor[leftmotor] = 0;
	motor[rightmotor] = 0;
}
// moves backward
// for moving forward and backward julio setup and interger called "timeMoving"
void moveBackward(int timeMoving) {
	wait1Msec(250);
	motor[leftmotor] = -60;
	motor[rightmotor] = -76;
	wait1Msec(timeMoving);
	motor[leftmotor] = 0;
	motor[rightmotor] = 0;
}
// opens claw duh
void openClaw() {
	wait1Msec(250);
	motor[clawmotor] = -60;
	wait1Msec(800);
	motor[clawmotor] = 0;
}
// closes the robot's claw
void closeClaw() {
	wait1Msec(250);
	motor[clawmotor] = 60;
	wait1Msec(800);
	motor[clawmotor] = 0;
}
// elevates the arm
void elevateArm(int timeMoving) {
	wait1Msec(250);
	motor[armmotor] = 100;
	wait1Msec(timeMoving);
	motor[armmotor] = 0;
}
// lowers the arm
void lowerArm() {
	wait1Msec(250);
	motor[armmotor] = -100;
	wait1Msec(1000);
	motor[armmotor] = 0;
}
// turns the robot 90*
void rotate90(){
	wait1Msec(250);
	motor[rightmotor] = 60;
	motor[leftmotor] = -60;
	wait1Msec(925);
	motor[rightmotor] = 0;
	motor[leftmotor] = 0;
}
//rotates 180*
void rotate180(){
	rotate90();rotate90(); //genius because instead of writing the motors to move, just add two of the variable "rotate90"
}

// "The geniusness of this function is just 9.8/10"- IGN
void rotate270(){
	rotate90();rotate90();rotate90(); //genius
}
// task main is where the robot executes the code
task main() {
 //int whatever = 0;
	while(true) {

		if (vexRT[Btn8D] == 1) {
			//while(whatever < 3) {// runs 3 times
				moveForward(2000); //the robot moves forward for 3 secs
				if (vexRT[Btn8U] == 1) {
						openClaw();
				}
				else {
					openClaw();
					moveForward(300);
					closeClaw(); // gets the can
					elevateArm(100);
					moveForward(2000);
					elevateArm(400);
					moveForward(200);
					openClaw(); // throws away can
					moveBackward(1000);
					lowerArm();
					closeClaw();
					rotate180();
					moveForward(3300);
					rotate180(); // returns to starting posistion in line 83
					//whatever++; // adds the value of 1 to the interger whatever until it equals 3 (line 82)
					//}
					}
			}

		//Arm control
		if (vexRT[Btn5D] == 1)
			{
				motor[armmotor] = 100;
			}
		else if (vexRT[Btn6D] == 1)
			{
				motor[armmotor] = -100;
			}
		else {motor[armmotor] = 0;}

		//Claw control
		if (vexRT[Btn5U] == 1)
			{
				motor[clawmotor] = 100;
			}
		else if (vexRT[Btn6U] == 1)
			{
				motor[clawmotor] = -100;
			}
		else {motor[clawmotor] = 0;}

		//driving controls
		motor[leftmotor] = vexRT[Ch3] / 2;
    motor[rightmotor] = vexRT[Ch2] / 2;
	}
}
